import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.regex.Pattern;

import org.paukov.combinatorics.Factory;
import org.paukov.combinatorics.Generator;
import org.paukov.combinatorics.ICombinatoricsVector;

/**
 * generete the candidate: self-join of the largeItemSet product from CandidateItemSet 
 * @author ginofarisano
 *
 */
public class LargeItemSet {
	
	HashSet<HashSet<Item>> candidate;
	
	HashSet<HashSet<Item>> largeItemSet;
	
	int k;
	
	public HashSet<HashSet<Item>> generateCandidates(
			HashSet<HashSet<Item>> myStructure,int k) {
		
		candidate=new HashSet<HashSet<Item>>();
		
		largeItemSet=myStructure;
		
		List<HashSet<Item>> list = new ArrayList<HashSet<Item>>(myStructure);
		
		this.k=k;
		
		//Join Step: Ck is generated by joining Lk-1 with itself
		//list is more indicate for iterate on the elements
			
		
		//temp candidate for self join of the element
		HashSet<Item> temp;
		
		//is not possible to have item set with element of the same family. ex. [milk=low-fat milk, milk=natural whole milk]
		HashSet<String> keyInGroup;
		
		for(int i=0;i<list.size()-1;i++){
			
			keyInGroup=getKeyInGroup(list.get(i));
			
			for(int j=i+1;j<list.size();j++){
				

				for (Item singleItem: list.get(j)){
					
					//only the differente item must be added
					if(list.get(i).contains(singleItem))
						continue;
					//only the element in different column family is possible add
					if(keyInGroup.contains(singleItem.getKey()))
						continue;
				
					temp=new HashSet<Item>();
					temp.addAll(list.get(i));
					temp.add(singleItem);
					
					if(candidate.contains(temp))
						continue;
					candidate.add(temp);
					
				}
			
			}
		
		}
		
		return pruning();
		
	}
	
	/**
	 * it is important that in a large itemset there are not value on the same column family ex. {dead, alive}
	 * @param item1
	 * @return
	 */
	private HashSet<String> getKeyInGroup(HashSet<Item> item1) {
		
		HashSet<String> key=new HashSet<String>();
		
		for(Item keyValue: item1){
			
			key.add(keyValue.getKey());
			
		}
		
		return key;
		
	}
	
	/**
	 * generate all the subset of size k-1 and chek if are in the largeItemSet Structure
	 * if there are not delete the itemset
	 * 
	 * ex.
	 * 
	 * L3={abc, abd, acd, ace, bcd}
􏰀 	 * Self-joining: L3*L3 􏰁abcd by abc and abd,  􏰁acde by acd e ace 
􏰀	 * Pruning:
􏰁	 * acde is deleted becouse ade is not in L3
􏰀 	 * C4={abcd}
	 * 
	 * 
	 * @return
	 */
	private HashSet<HashSet<Item>> pruning() {
		
		ICombinatoricsVector<Item> initialVector;
		Generator<Item> gen;
		
		HashSet<HashSet<Item>> toRemove=new HashSet<HashSet<Item>>();
		
		for(HashSet<Item> item: candidate){
			
			initialVector=Factory.createVector(item);
			
			gen = Factory.createSimpleCombinationGenerator(initialVector, k-1);
			
			for (ICombinatoricsVector<Item> toTest : gen) {
				
				if(!largeItemSet.contains(new HashSet<Item>(toTest.getVector())))
		
					toRemove.add(item);
				
			}
		}
		
		candidate.removeAll(toRemove);
		
		return candidate;
			
	}
		
}


