import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map.Entry;

import org.paukov.combinatorics.Factory;
import org.paukov.combinatorics.Generator;
import org.paukov.combinatorics.ICombinatoricsVector;


public class CandidateItemSet {

	static //write the rules in a file
	Writer writer;
	
	HashSet <HashSet<Item>> candidate;
	//size of the itemset
	int k;




	//Ck is generated by joining Lk-1 with itself
	public CandidateItemSet() throws UnsupportedEncodingException, FileNotFoundException{

		writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(Costants.OUTPUTFILE), "utf-8"));

	}




	/**
	 * count the occurance of the candidates (of size k) in the dataset
	 * @param myStructure
	 * @param k
	 * @return
	 * @throws IOException
	 */
	public HashSet<HashSet<Item>> generateLargeItemSet(HashSet<HashSet<Item>> myStructure, int k) throws IOException{

		candidate=myStructure;
		this.k=k;
		
		float support;
		float dinamicSupport;
		
		//remove the element with support<=dinamicsupport
		//i can't remove an item in a cicle
		HashSet <HashSet<Item>> toRemove=new HashSet <HashSet<Item>>();
		
		for(HashSet<Item> item : candidate){

			support=DataSet.supportOfAnItemset(item);

			dinamicSupport=DinamicSupport.getDinamicSupport(item);

			//for k=1 don't calculate the confidence
			if((support>dinamicSupport)){
				printRules(support,dinamicSupport,item);
			} else
				toRemove.add(item);


		}
		
		//remove all candidate that have support<dinamicSupport
		candidate.removeAll(toRemove);
		
		return candidate;



	}



	/**
	 * print the reles that have suppor>dinamicSupport and confidence>Costants.minConfidence
	 * @param support
	 * @param dinamicSupport
	 * @param item
	 * @throws IOException
	 */
	private void printRules(float support, float dinamicSupport, HashSet<Item> item) throws IOException {
		
		System.out.println("\n\nLarge itemset "+item.toString());
		System.out.println("");
		writer.append("\n\nLarge itemset "+item.toString());
		writer.append("\n");
		
		System.out.println("\n\nSupport: "+support+"; DinamicSupport: "+dinamicSupport);
		System.out.println("");
		
		writer.append("\n\nSupport: "+support+"; DinamicSupport: "+dinamicSupport);
		writer.append("\n");
		
		if(k>1){
			
		
			//left side
			ICombinatoricsVector<Item> initialVector= Factory.createVector(item);
			//all the combination of size k-1
			//ex. if have large itemset {A,B,C} then {A,B}->C,  {A,C}->B, {B,C}->{A}
			Generator<Item> genLeft = Factory.createSimpleCombinationGenerator(initialVector, k-1);
		
			//is atomic but DataSet.supportOfAnItemset take an HashSet<Item>
			HashSet<Item> rightSideSet;
			HashSet<Item> leftSideSet;
			
			
			float confidence;
		
			for (ICombinatoricsVector<Item> combinationLeft : genLeft) {
			
				leftSideSet = new HashSet<Item>(combinationLeft.getVector());
				
				
				for (Item rightSide : item) {
					
					rightSideSet = new HashSet<Item>();
					
					
					if(!combinationLeft.contains(rightSide)){
					
						rightSideSet.add(rightSide);
					
						confidence=support/DataSet.supportOfAnItemset(leftSideSet);
						
						if((support>dinamicSupport) && (confidence>Costants.MINCONFIDENCE)){
							
							
							System.out.println("Confidence: "+confidence);
							System.out.println("");
							System.out.println(leftSideSet+"->"+rightSide);
							System.out.println("");
							
							writer.append("Confidence: "+confidence);
							writer.append("\n");
							writer.append(leftSideSet+"->"+rightSide);
							writer.append("\n");
							
							
						}
						
						
					
					}
				
				}
			
			}
		
		}

	}

	/**
	 * close the stream in the output file
	 * @throws IOException
	 */
	public static void closeStreamFile() throws IOException {
		writer.close();
		
	}


}